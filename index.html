<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Planet Absorb — Bigger Black Holes + Wider Gravity + More Particles</title>
  <style>
    html, body { margin:0; padding:0; background:#000; overflow:hidden; }
    canvas { display:block; touch-action:none; user-select:none; -webkit-user-select:none; -webkit-touch-callout:none; }
    .hud{
      position:fixed; left:12px; top:12px;
      color:rgba(255,255,255,.88);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial;
      font-size:13px; line-height:1.35;
      user-select:none;
      background:rgba(0,0,0,.35);
      padding:10px 12px; border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(6px);
      max-width: 760px;
    }
    .hud b{ color:#fff; }
    .hud .row{ margin-top:6px; opacity:.95; }
    .hud kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      background: rgba(255,255,255,0.12);
      padding: 2px 6px; border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.14);
    }
    .warn { color: rgba(255,190,140,.98); }
    .danger { color: rgba(255,120,120,.98); }
  
    .resetBtn{
      position:fixed; right:16px; top:12px; z-index:60;
      padding:0;
      border:none;
      background:transparent;
      color:#fff;
      font:700 10px/1 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      letter-spacing:.06em;
      user-select:none; -webkit-user-select:none; -webkit-touch-callout:none;
      touch-action: manipulation;
    }
    .resetBtn:active{ opacity:0.7; }
    @media (max-width:700px){
      .resetBtn{ font-size:10px; }
    }


  /* --- Minimal UI (text only) --- */
  #infoTop{
    position:fixed; top:12px; left:16px; z-index:50;
    color:#fff; font:10px/1.2 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    user-select:none; -webkit-user-select:none; -webkit-touch-callout:none;
    pointer-events:none;
    text-shadow:none;
  }
  #infoBottom{
    position:fixed; bottom:16px; left:50%; transform:translateX(-50%); z-index:50;
    color:#fff; font:10px/1.2 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    user-select:none; -webkit-user-select:none; -webkit-touch-callout:none;
    pointer-events:none;
    text-shadow:none;
    white-space:nowrap;
  }
  /* Hide any other HUD/help panels if they exist */
  #hud, #help, #panel, #ui, #stats, #reset, #tips, #instructions, #legend{
    display:none !important;
  }
  @media (max-width: 700px){
    #infoTop{ font-size:10px; }
    #infoBottom{ font-size:10px; }
  }


    /* Ensure legacy HUD is hidden */
  .hud { display:none !important; }

</style>
</head>
<body>
<canvas id="c"></canvas>

  <div id="infoTop"></div>
  <div id="infoBottom"></div>
<button id="resetBtn" class="resetBtn" type="button">RESET</button>

<div class="hud">
  <div><b>Planet Absorb</b> — 클릭 추진(관성) + 플레이어 중력권 + 블랙홀(느리면 포획 / 빠르면 스윙바이-속도고정)</div>
  <div class="row">
    조작:
    <kbd>클릭/터치</kbd> 방향 추진(관성), <kbd>휠/핀치</kbd> 줌,
    <kbd>Space/롱탭</kbd> 부스트, <kbd>R</kbd> 리셋
  </div>
  <div class="row">
    변경: 블랙홀 크기 최대 5배(개체별 랜덤), 중력권 1.5배, 블랙홀 파티클 10배+
  </div>
  <div class="row" id="stats"></div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');


  // --- Minimal UI refs (text only) ---
  const infoTopEl = document.getElementById('infoTop');
  const infoBottomEl = document.getElementById('infoBottom');
  const resetBtnEl = document.getElementById('resetBtn');
  if (resetBtnEl) resetBtnEl.addEventListener('click', () => reset());

  function pad3(n){
    const v = Math.floor(Math.max(0, Number(n) || 0));
    return String(v).padStart(3,'0');
  }

  function updateMinimalUI(){
    // mass / radius / speed (no decimals)
    const spd = Math.hypot(player.vx, player.vy);
    if (infoTopEl){
      infoTopEl.textContent = `질량 : ${pad3(player.mass)} / 반지름 : ${pad3(playerR())} / 속도 : ${pad3(spd)}`;
    }
    if (infoBottomEl){
      infoBottomEl.textContent = 'Move : Click/Touch 또는 Hold+Drag, Zoom : Wheel/Pinch';
    }
  }
  // --- Mobile: prevent long-press selection/callout inside game area
  canvas.addEventListener('contextmenu', (e) => e.preventDefault());
  document.addEventListener('selectstart', (e) => { if (e.target === canvas) e.preventDefault(); });
  // iOS Safari sometimes fires these during pinch/zoom gestures
  document.addEventListener('gesturestart', (e) => { if (e.target === canvas) e.preventDefault(); }, { passive:false });
  document.addEventListener('gesturechange', (e) => { if (e.target === canvas) e.preventDefault(); }, { passive:false });
  document.addEventListener('gestureend', (e) => { if (e.target === canvas) e.preventDefault(); }, { passive:false });
  const ctx = canvas.getContext('2d', { alpha:false });
  const statsEl = document.getElementById('stats');
  const resetBtn = document.getElementById('resetBtn');

  resetBtn.addEventListener('click', () => reset());

  const DPR = Math.min(2, window.devicePixelRatio || 1);
  function resize() {
    canvas.width = Math.floor(window.innerWidth * DPR);
    canvas.height = Math.floor(window.innerHeight * DPR);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    canvas.style.touchAction = 'none';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // ---------- Utils
  const rand = (a,b)=> a + Math.random()*(b-a);
  const clamp = (v,a,b)=> Math.max(a, Math.min(b,v));
  const hypot = Math.hypot;

  // ---------- CONFIG
  const CONFIG = {
    worldScale: 10,
    camFollow: 0.10,
    zoomMin: 0.35,
    zoomMax: 2.4,
    zoomWheelSpeed: 0.0012,

    // player impulse (no damping)
    impulseStrength: 0.62,
    brakeMultiplier: 1.25,
    turnMultiplier: 1.00,
    boostMultiplier: 1.85,

    // size-scaled speed (bigger = faster)
    sizeSpeedExponent: 0.55,
    baseMaxSpeed: 13.5,
    maxSpeedCap: 28.0,

    // combo
    comboWindowMs: 180,
    comboAngleDeg: 22,
    comboBonusPerHit: 0.22,
    comboBonusCap: 1.2,

    // mass->radius
    radiusK: 2.6,

    // small planets
    smallPlanetCount: 320,
    smallMassMin: 2.0,
    smallMassMax: 28.0,

    // absorb
    absorbGainMultiplier: 1.0,
    playerMinMass: 10,

    // black holes
    blackHoleCount: 10,

    // "기존 크기" 랜덤 범위 (이 값을 기반 r0로 잡고, r = r0 * (1~5))
    bhRadiusMin: 12,
    bhRadiusMax: 20,
    bhSizeMaxFactor: 5.0,

    // base strength (r0 기준) — 실제 strength는 크기 배수에 따라 보정
    bhStrengthMin: 2600,
    bhStrengthMax: 4200,

    bhKillRadiusMultiplier: 1.15,
    bhPullRadiusMultiplier: 16,
    bhRangeMultiplier: 1.5,    // ✅ 블랙홀 영향 범위 1.5배

    // speed-based mode switch
    bhCaptureSpeed: 6.2,
    bhCaptureRadiusFactor: 0.80,

    // Capture mode (slow): pull
    bhCapturePull: 1.65,
    bhCaptureMaxAccel: 2.2,
    bhCaptureSwirl: 0.25,

    // Swing-by mode (fast): KEEP SPEED, only bend direction
    bhSwingTurnRate: 2.6,
    bhSwingMaxTurnPerSec: 2.4,
    bhSwingPullAssist: 0.18,

    // falloff
    bhFalloffPower: 1.2,

    // drain
    bhDrainPerSec: 16,
    bhDrainNearMultiplier: 3.4,

    // ✅ BH particle boost (10배+)
    bhParticleChanceBase: 1.0,   // 기존 0.10*fall -> 이제 fall 자체로(≈10배)
    bhParticleExtraClose: 1.0,   // 가까울 때 추가 1개 더 나올 확률 가중

    // player gravity field
    playerGravityRangeMult: 6.0,
    playerGravityStrength: 48.0,
    playerGravityMaxAccel: 1.35,
    playerGravityFalloffPower: 1.15,

    // visuals
    starCount: 520,
    trailLength: 22,
    particleMax: 3000,           // 파티클 늘리니 상한도 함께↑
    particleSpawnPerSec: 140,    // (참고용)
    clickPingMs: 220,
  };

  // ---------- World (simulation space; fixed after first init)
  const world = { w: 1, h: 1 };
  let worldInitialized = false;
  function initWorldSizeOnce(){
    if(worldInitialized) return;
    world.w = Math.max(2000, window.innerWidth  * CONFIG.worldScale);
    world.h = Math.max(2000, window.innerHeight * CONFIG.worldScale);
    worldInitialized = true;
  }

  // ---------- Toroidal wrap
  function wrapPos(p) {
    if (p.x < 0) p.x += world.w;
    if (p.x >= world.w) p.x -= world.w;
    if (p.y < 0) p.y += world.h;
    if (p.y >= world.h) p.y -= world.h;
  }
  function torusDelta(ax, ay, bx, by) {
    let dx = bx - ax;
    let dy = by - ay;
    if (dx >  world.w/2) dx -= world.w;
    if (dx < -world.w/2) dx += world.w;
    if (dy >  world.h/2) dy -= world.h;
    if (dy < -world.h/2) dy += world.h;
    return { dx, dy };
  }
  function torusDist(ax, ay, bx, by) {
    const {dx, dy} = torusDelta(ax, ay, bx, by);
    return hypot(dx, dy);
  }

  // ---------- Camera
  const camera = { x: 0, y: 0, zoom: 1.0 };
  function screenToWorld(sx, sy) {
    const cx = window.innerWidth * 0.5;
    const cy = window.innerHeight * 0.5;
    const wx = camera.x + (sx - cx) / camera.zoom;
    const wy = camera.y + (sy - cy) / camera.zoom;
    return {
      x: ((wx % world.w) + world.w) % world.w,
      y: ((wy % world.h) + world.h) % world.h
    };
  }
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const before = screenToWorld(mx, my);
    const delta = -e.deltaY * CONFIG.zoomWheelSpeed;
    camera.zoom = clamp(camera.zoom * (1 + delta), CONFIG.zoomMin, CONFIG.zoomMax);

    const after = screenToWorld(mx, my);
    const {dx, dy} = torusDelta(after.x, after.y, before.x, before.y);
    camera.x = ((camera.x + dx) % world.w + world.w) % world.w;
    camera.y = ((camera.y + dy) % world.h + world.h) % world.h;
  }, { passive:false });

  // ---------- Stars
  let stars = [];
  function makeStars() {
    stars = [];
    for (let i=0;i<CONFIG.starCount;i++){
      stars.push({ x: rand(0, world.w), y: rand(0, world.h), r: rand(0.6, 1.8), a: rand(0.20, 0.85) });
    }
  }

  // ---------- Entities
  const radiusFromMass = (m)=> CONFIG.radiusK * Math.sqrt(Math.max(0.01, m));

  const player = {
    x: 0, y: 0, vx: 0, vy: 0, mass: 90,
    trail: [],
    lastClickAt: 0,
    lastClickDirX: 1,
    lastClickDirY: 0,
    comboBonus: 0,
    clickPingAt: 0,
    clickDirX: 1,
    clickDirY: 0,
  };

  const playerR = ()=> radiusFromMass(player.mass);
  const refR = ()=> radiusFromMass(90);

  function sizeSpeedScale() {
    const s = Math.pow(playerR() / refR(), CONFIG.sizeSpeedExponent);
    return clamp(s, 0.75, 3.2);
  }
  function maxSpeedNow() {
    return Math.min(CONFIG.maxSpeedCap, CONFIG.baseMaxSpeed * sizeSpeedScale());
  }

  const smalls = [];
  function spawnSmall(avoidX, avoidY, avoidR) {
    for (let tries=0; tries<120; tries++){
      const mass = rand(CONFIG.smallMassMin, CONFIG.smallMassMax);
      const r = radiusFromMass(mass);
      const x = rand(0, world.w);
      const y = rand(0, world.h);
      const d = torusDist(x, y, avoidX, avoidY);
      if (d > (avoidR + r + 120)) {
        return { x,y, vx: rand(-0.25,0.25), vy: rand(-0.25,0.25), mass, hue: rand(190,235), trail: [] };
      }
    }
    const mass = rand(CONFIG.smallMassMin, CONFIG.smallMassMax);
    return { x: rand(0,world.w), y: rand(0,world.h), vx:0, vy:0, mass, hue: rand(190,235), trail: [] };
  }

  const blackholes = [];
  function spawnStaticBlackHole() {
    // ✅ "이전(기존) 크기" r0를 뽑고, 1~5배 랜덤으로 최종 반지름 결정
    const r0 = rand(CONFIG.bhRadiusMin, CONFIG.bhRadiusMax);
    const factor = rand(1.0, CONFIG.bhSizeMaxFactor);
    const r = r0 * factor;

    // ✅ 크기가 커지면 체감상 영향도도 커져야 자연스러움
    // (너무 과하면 튜닝이 어려워서 완만한 지수)
    const baseStrength = rand(CONFIG.bhStrengthMin, CONFIG.bhStrengthMax);
    const strength = baseStrength * Math.pow(factor, 1.15);

    return { x: rand(0, world.w), y: rand(0, world.h), r, strength, factor };
  }

  // particles (vibe)
  const particles = [];
  function spawnParticle(fromX, fromY, toX, toY, speed, life, hue, alpha) {
    if (particles.length >= CONFIG.particleMax) return;
    const {dx, dy} = torusDelta(fromX, fromY, toX, toY);
    const d = Math.max(0.001, hypot(dx,dy));
    const vx = (dx/d) * speed + rand(-0.15, 0.15);
    const vy = (dy/d) * speed + rand(-0.15, 0.15);
    particles.push({ x: fromX, y: fromY, vx, vy, life, maxLife: life, hue, alpha, size: rand(0.8, 2.2) });
  }

  // jet particles (thrust visuals) - no-op safe if visuals are disabled
  function addJetParticles(x, y, backDirX, backDirY, power){
    // backDir should point opposite to input direction
    const amt = Math.max(2, Math.min(18, Math.floor(power * 10)));
    const bx = backDirX, by = backDirY;
    const bLen = Math.max(0.001, hypot(bx, by));
    const nx = bx / bLen, ny = by / bLen;
    for (let i=0;i<amt;i++){
      const ox = x + nx * rand(2, 10) + rand(-2,2);
      const oy = y + ny * rand(2, 10) + rand(-2,2);
      const tx = x + nx * rand(18, 40);
      const ty = y + ny * rand(18, 40);
      spawnParticle(ox, oy, tx, ty, rand(0.6, 2.6), rand(12, 28), rand(25, 55), rand(0.25, 0.65));
    }
  }

  // ---------- Rendering helpers
  function shiftIntoView(x, y) {
    const {dx, dy} = torusDelta(camera.x, camera.y, x, y);
    return { x: camera.x + dx, y: camera.y + dy };
  }
  function beginCamera() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,window.innerWidth, window.innerHeight);
    const cx = window.innerWidth * 0.5;
    const cy = window.innerHeight * 0.5;
    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-camera.x, -camera.y);
  }
  function endCamera() { ctx.restore(); }

  function drawStars() {
    const viewHalfW = (window.innerWidth * 0.5) / camera.zoom;
    const viewHalfH = (window.innerHeight * 0.5) / camera.zoom;
    const pad = 60;
    for (const s of stars) {
      const p = shiftIntoView(s.x, s.y);
      if (p.x < camera.x - viewHalfW - pad || p.x > camera.x + viewHalfW + pad ||
          p.y < camera.y - viewHalfH - pad || p.y > camera.y + viewHalfH + pad) continue;
      ctx.fillStyle = `rgba(255,255,255,${s.a})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, s.r, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function drawTrail(trail, baseHue, alphaBase) {
    if (trail.length < 2) return;
    for (let i=1; i<trail.length; i++) {
      const a = (i / trail.length) * alphaBase;
      const p0 = trail[i-1], p1 = trail[i];
      ctx.strokeStyle = `hsla(${baseHue}, 90%, 70%, ${a})`;
      ctx.lineWidth = 1.0 / camera.zoom;
      ctx.beginPath();
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(p1.x, p1.y);
      ctx.stroke();
    }
  }

  function drawSmall(s) {
    const r = radiusFromMass(s.mass);
    const p = shiftIntoView(s.x, s.y);
    drawTrail(s.trail, s.hue, 0.16);

    const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * 2.2);
    glow.addColorStop(0, `hsla(${s.hue}, 90%, 70%, 0.22)`);
    glow.addColorStop(1, `hsla(${s.hue}, 90%, 50%, 0)`);
    ctx.fillStyle = glow;
    ctx.beginPath(); ctx.arc(p.x, p.y, r * 2.2, 0, Math.PI*2); ctx.fill();

    const core = ctx.createRadialGradient(p.x - r*0.25, p.y - r*0.25, r*0.15, p.x, p.y, r);
    core.addColorStop(0, `hsla(${s.hue}, 90%, 78%, 1)`);
    core.addColorStop(1, `hsla(${s.hue}, 90%, 55%, 1)`);
    ctx.fillStyle = core;
    ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
  }

  function drawPlayer() {
    const r = playerR();
    const p = shiftIntoView(player.x, player.y);

    drawTrail(player.trail, 32, 0.22);

    // player gravity ring
    const gR = r * CONFIG.playerGravityRangeMult;
    ctx.strokeStyle = 'rgba(255,180,90,0.18)';
    ctx.lineWidth = 1.2 / camera.zoom;
    ctx.beginPath();
    ctx.arc(p.x, p.y, gR, 0, Math.PI*2);
    ctx.stroke();

    const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r*3.0);
    glow.addColorStop(0, 'rgba(255,200,120,0.32)');
    glow.addColorStop(0.35,'rgba(255,140,60,0.16)');
    glow.addColorStop(1,'rgba(255,120,40,0)');
    ctx.fillStyle = glow;
    ctx.beginPath(); ctx.arc(p.x, p.y, r*3.0, 0, Math.PI*2); ctx.fill();

    const core = ctx.createRadialGradient(p.x - r*0.25, p.y - r*0.25, r*0.18, p.x, p.y, r);
    core.addColorStop(0,'rgba(255,235,170,1)');
    core.addColorStop(0.55,'rgba(255,165,70,1)');
    core.addColorStop(1,'rgba(210,75,15,1)');
    ctx.fillStyle = core;
    ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();

    const now = performance.now();
    if (now - player.clickPingAt < CONFIG.clickPingMs) {
      const len = (r * 2.2);
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 2 / camera.zoom;
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x + player.clickDirX * len, p.y + player.clickDirY * len);
      ctx.stroke();
    }
  }

  function drawBlackHole(bh) {
    const p = shiftIntoView(bh.x, bh.y);
    const r = bh.r;
    const pullR = r * CONFIG.bhPullRadiusMultiplier * CONFIG.bhRangeMultiplier; // ✅ 1.5배
    const killR = r * CONFIG.bhKillRadiusMultiplier;

    const ring = ctx.createRadialGradient(p.x, p.y, killR, p.x, p.y, pullR);
    ring.addColorStop(0, 'rgba(120,180,255,0.14)');
    ring.addColorStop(1, 'rgba(120,180,255,0)');
    ctx.fillStyle = ring;
    ctx.beginPath(); ctx.arc(p.x, p.y, pullR, 0, Math.PI*2); ctx.fill();

    const halo = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r*3.8);
    halo.addColorStop(0, 'rgba(90,150,255,0.22)');
    halo.addColorStop(0.45,'rgba(120,200,255,0.10)');
    halo.addColorStop(1,'rgba(120,200,255,0)');
    ctx.fillStyle = halo;
    ctx.beginPath(); ctx.arc(p.x, p.y, r*3.8, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = 'rgba(0,0,0,1)';
    ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = 'rgba(170,220,255,0.35)';
    ctx.lineWidth = 1 / camera.zoom;
    ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.stroke();
  }

  function drawParticles() {
    for (const pt of particles) {
      const p = shiftIntoView(pt.x, pt.y);
      const a = pt.alpha * (pt.life / pt.maxLife);
      ctx.fillStyle = `hsla(${pt.hue}, 90%, 70%, ${a})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, pt.size, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // ---------- Input
    function normalize(dx, dy) {
    const d = Math.max(1e-6, hypot(dx, dy));
    return { x: dx / d, y: dy / d, d };
  }
  function angleBetween(ax, ay, bx, by) {
    const dot = clamp(ax*bx + ay*by, -1, 1);
    return Math.acos(dot);
  }

  
  function applyImpulseToWorld(wx, wy) {
    const {dx, dy} = torusDelta(player.x, player.y, wx, wy);
    const dir = normalize(dx, dy);

    const cap = maxSpeedNow();
    const vmag = hypot(player.vx, player.vy);
    const vfrac = clamp(vmag / Math.max(1e-6, cap), 0, 1);

    // Determine if this input is opposite to current movement (for "reverse thrust" braking).
    let brake = false;
    if (vmag > 0.4) {
      const vdirx = player.vx / vmag, vdiry = player.vy / vmag;
      const dot = dir.x * vdirx + dir.y * vdiry;
      brake = (dot < -0.25);
    }

    const now = performance.now();
    const dtMs = now - player.lastClickAt;

    // combo detection (same window/angle tuning as before)
    let comboHit = false;
    if (dtMs <= CONFIG.comboWindowMs) {
      const lastN = normalize(player.lastClickDirX, player.lastClickDirY);
      const ang = angleBetween(lastN.x, lastN.y, dir.x, dir.y);
      const angDeg = ang * 180 / Math.PI;
      comboHit = (angDeg <= CONFIG.comboAngleDeg);
      if (!comboHit) player.comboBonus *= 0.35;
    } else {
      player.comboBonus *= 0.6;
    }
    if (comboHit) player.comboBonus = clamp(player.comboBonus + CONFIG.comboBonusPerHit, 0, CONFIG.comboBonusCap);

    // --- Accel curve: make spam less explosive and require absolute time to reach high speed.
    // Base impulse is reduced and further attenuated as speed approaches cap.
    let impulse = CONFIG.impulseStrength * 0.65;
    const ease = Math.pow(0.25 + 0.75 * (1 - vfrac), 1.2); // 1 -> slow near cap
    impulse *= ease;

    // Very fast re-taps get slightly less immediate impulse (keeps the existing "delayed/gradual" feel).
    if (dtMs <= 180) impulse *= 0.60;

    // Apply base impulse in the input direction (accelerate or decelerate depending on alignment).
    player.vx += dir.x * impulse;
    player.vy += dir.y * impulse;

    // BOOST (B 방식): for a combo input, add ONE extra impulse that only increases speed.
    // Gate: only starts contributing after reaching a certain speed band, and ramps in smoothly.
    if (comboHit) {
      const gate = 0.55; // start after 55% of max speed
      const ramp = clamp((vfrac - gate) / Math.max(1e-6, (1 - gate)), 0, 1);
      if (ramp > 0) {
        const vmag2 = hypot(player.vx, player.vy);
        let vdx = dir.x, vdy = dir.y;
        if (vmag2 > 0.15) { vdx = player.vx / vmag2; vdy = player.vy / vmag2; }
        const extra = impulse * ramp; // ramps from 0 -> 1x impulse
        player.vx += vdx * extra;
        player.vy += vdy * extra;
      }
    }

    // Steering assist (Option B): clicking slightly off-forward can still bias direction,
    // but steering NEVER changes speed magnitude.
    {
      const sp3 = hypot(player.vx, player.vy);
      if (sp3 > 0.05) {
        const cx = player.vx / sp3, cy = player.vy / sp3;
        const ang = angleBetween(cx, cy, dir.x, dir.y) * 180 / Math.PI;
        const strength = (ang <= STEER_FORWARD_DEG) ? STEER_FORWARD_SCALE : 1;
        requestSteerAttempt(dir.x, dir.y, strength);
      }
    }

    player.lastClickAt = now;
    player.lastClickDirX = dir.x;
    player.lastClickDirY = dir.y;
    player.clickPingAt = now;

    addJetParticles(player.x, player.y, -dir.x, -dir.y, impulse * 0.18);

    // trail
    player.trail.push({ x: player.x, y: player.y, t: now });
    while (player.trail.length > CONFIG.trailMax) player.trail.shift();
  }

  // --- Pointer / Touch controls
  // - Tap/Click: impulse (accel / reverse-thrust brake)
  // - Combo within window: extra impulse (B 방식) but only after reaching a speed band (no instant jump)
  // - Hold + Drag: steering only (no accel). Holding still does nothing.
  // - Pinch (2 fingers): zoom

  const activePointers = new Map(); // pointerId -> {x,y,type}

  // Pinch state
  let pinchState = null; // {dist, zoom, midX, midY}

  // Tap/Drag state
  let primaryPointer = null; // {id, type, sx, sy, downClientX, downClientY, moved, lastSX, lastSY}
  const TAP_MOVE_PX = 14;

  // Steering request (only when a steer attempt is allowed by rate-limit)
  // NOTE: steering changes direction ONLY (speed magnitude preserved).
  const steer = { dirX: 0, dirY: 0, lastUpdate: -1, lastApply: -1, strength: 1 };

  // Steering is applied for a short "burst" after each allowed attempt.
  const STEER_ACTIVE_MS = 90;      // how long the burst remains active after an attempt (ms)
  const STEER_RATE = 4.2;          // rad/sec base (smooth turn rate)
  const STEER_COOLDOWN_MS = CONFIG.comboWindowMs; // match double-click / combo timing
  const STEER_FORWARD_DEG = 20;    // forward cone for "mostly forward" inputs
  const STEER_FORWARD_SCALE = 0.35;// weak steering inside forward cone (Option B)
  const STEER_SPEED_THRESHOLD = 1.0; // below this, steering behaves like before
  const STEER_SPEED_SCALE = 1.7;     // above threshold, steering gets harder as speed rises

  function canvasPointFromEvent(e){
    const rect = canvas.getBoundingClientRect();
    return { sx: e.clientX - rect.left, sy: e.clientY - rect.top, rect };
  }

  function updateSteerFromScreen(sx, sy){
    const w = screenToWorld(sx, sy);
    const {dx, dy} = torusDelta(player.x, player.y, w.x, w.y);
    const n = normalize(dx, dy);

    // Determine steering strength (Option B): if input is mostly forward, steer weaker.
    let strength = 1;
    const sp = hypot(player.vx, player.vy);
    if (sp > 0.4) {
      const cx = player.vx / sp, cy = player.vy / sp;
      const ang = angleBetween(cx, cy, n.x, n.y) * 180 / Math.PI;
      if (ang <= STEER_FORWARD_DEG) strength = STEER_FORWARD_SCALE;
    }
    requestSteerAttempt(n.x, n.y, strength);
  }

  function requestSteerAttempt(dirX, dirY, strength){
    const now = performance.now();
    if (steer.lastApply > 0 && (now - steer.lastApply) < STEER_COOLDOWN_MS) return;
    steer.dirX = dirX; steer.dirY = dirY;
    steer.strength = strength;
    steer.lastUpdate = now;
    steer.lastApply = now;
  }

  function startOrUpdatePinch(){
    const pts = [...activePointers.values()].filter(p => p.type === 'touch');
    if (pts.length !== 2) { pinchState = null; return; }

    const a = pts[0], b = pts[1];
    const pdx = a.x - b.x, pdy = a.y - b.y;
    const dist = Math.max(1e-6, Math.hypot(pdx, pdy));
    const midX = (a.x + b.x) * 0.5;
    const midY = (a.y + b.y) * 0.5;

    if (!pinchState){
      pinchState = { dist, zoom: camera.zoom, midX, midY };
      return;
    }

    const scale = dist / pinchState.dist;
    const rect = canvas.getBoundingClientRect();
    const mx = midX - rect.left;
    const my = midY - rect.top;

    const before = screenToWorld(mx, my);
    camera.zoom = clamp(pinchState.zoom * scale, CONFIG.zoomMin, CONFIG.zoomMax);
    const after = screenToWorld(mx, my);

    // keep midpoint anchored
    const {dx: cdx, dy: cdy} = torusDelta(after.x, after.y, before.x, before.y);
    camera.x = (camera.x + cdx + world.w) % world.w;
    camera.y = (camera.y + cdy + world.h) % world.h;
  }

  canvas.addEventListener('pointerdown', (e) => {
    canvas.setPointerCapture?.(e.pointerId);
    if ((e.pointerType || '') === 'touch') e.preventDefault();

    const { sx, sy } = canvasPointFromEvent(e);
    activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, type: e.pointerType || 'mouse' });

    // Touch: if second finger appears -> pinch mode
    if ((e.pointerType || '') === 'touch') {
      if ([...activePointers.values()].filter(p => p.type === 'touch').length >= 2) {
        primaryPointer = null; // cancel single-finger tap/drag
        startOrUpdatePinch();
        return;
      }
    }

    // Track primary pointer for tap vs drag steering
    primaryPointer = {
      id: e.pointerId,
      type: e.pointerType || 'mouse',
      sx, sy,
      downClientX: e.clientX,
      downClientY: e.clientY,
      moved: false,
      lastSX: sx,
      lastSY: sy
    };
  });

  canvas.addEventListener('pointermove', (e) => {
    if ((e.pointerType || '') === 'touch') e.preventDefault();
    if (!activePointers.has(e.pointerId)) return;

    activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, type: e.pointerType || 'mouse' });

    // Pinch zoom (touch only)
    if ((e.pointerType || '') === 'touch') {
      startOrUpdatePinch();
      if ([...activePointers.values()].filter(p => p.type === 'touch').length >= 2) return;
    }

    // Single pointer steering (hold + drag only)
    if (!primaryPointer || primaryPointer.id !== e.pointerId) return;

    const { sx, sy } = canvasPointFromEvent(e);

    // mark as moved if it exceeds tap slop
    const dx0 = sx - primaryPointer.sx;
    const dy0 = sy - primaryPointer.sy;
    if (Math.hypot(dx0, dy0) > TAP_MOVE_PX) primaryPointer.moved = true;

    // Only steer when the pointer position CHANGES while held.
    const dmove = Math.hypot(sx - primaryPointer.lastSX, sy - primaryPointer.lastSY);
    if (dmove > 1.0) {
      updateSteerFromScreen(sx, sy);
      primaryPointer.lastSX = sx;
      primaryPointer.lastSY = sy;
    }
  });

  function finishPrimaryAsTap(){
    if (!primaryPointer) return;
    if (primaryPointer.moved) return; // drag steering only (no accel)
    const w = screenToWorld(primaryPointer.sx, primaryPointer.sy);
    applyImpulseToWorld(w.x, w.y);
  }

  canvas.addEventListener('pointerup', (e) => {
    if ((e.pointerType || '') === 'touch') e.preventDefault();
    if (activePointers.has(e.pointerId)) activePointers.delete(e.pointerId);

    // Leaving pinch mode
    if ((e.pointerType || '') === 'touch') {
      if ([...activePointers.values()].filter(p => p.type === 'touch').length < 2) pinchState = null;
    }

    if (primaryPointer && primaryPointer.id === e.pointerId) {
      // Tap (no movement) => impulse. Drag => steering only.
      finishPrimaryAsTap();
      primaryPointer = null;
    }
  });

  canvas.addEventListener('pointercancel', (e) => {
    if (activePointers.has(e.pointerId)) activePointers.delete(e.pointerId);
    pinchState = null;
    if (primaryPointer && primaryPointer.id === e.pointerId) primaryPointer = null;
  });


  // ---------- Counters

  let absorbedCount = 0;
  let survivedSec = 0;

  // ---------- Reset
  function reset() {
    initWorldSizeOnce();
    makeStars();

    // --- 1) baseline player state (mass first so playerR() is stable)
    player.vx = 0; player.vy = 0;
    player.mass = 90;
    player.trail.length = 0;
    player.lastClickAt = 0;
    player.lastClickDirX = 1;
    player.lastClickDirY = 0;
    player.comboBonus = 0;
    player.clickPingAt = 0;

    // --- 2) spawn black holes first
    blackholes.length = 0;
    for (let i=0;i<CONFIG.blackHoleCount;i++){
      blackholes.push(spawnStaticBlackHole());
    }

    // --- 3) pick a safe spawn position (outside all BH pull ranges + margin)
    function isSafeSpawn(x, y) {
      const pr = playerR();
      for (const bh of blackholes) {
        const pullR = bh.r * CONFIG.bhPullRadiusMultiplier * CONFIG.bhRangeMultiplier;
        const d = torusDist(x, y, bh.x, bh.y);
        // margin: pullR + player radius + extra padding
        if (d < pullR + pr + 180) return false;
      }
      return true;
    }

    function findSafeSpawn() {
      // Try random points first
      for (let tries=0; tries<260; tries++) {
        const x = rand(0, world.w);
        const y = rand(0, world.h);
        if (isSafeSpawn(x, y)) return {x, y};
      }
      // Fallback: choose the "best" among samples (max distance to nearest pullR)
      let best = { x: world.w*0.5, y: world.h*0.5 };
      let bestScore = -1e9;
      for (let tries=0; tries<220; tries++) {
        const x = rand(0, world.w);
        const y = rand(0, world.h);
        let minClear = 1e9;
        for (const bh of blackholes) {
          const pullR = bh.r * CONFIG.bhPullRadiusMultiplier * CONFIG.bhRangeMultiplier;
          const d = torusDist(x, y, bh.x, bh.y);
          minClear = Math.min(minClear, d - pullR);
        }
        if (minClear > bestScore) {
          bestScore = minClear;
          best = {x, y};
        }
      }
      return best;
    }

    const spawn = findSafeSpawn();
    player.x = spawn.x;
    player.y = spawn.y;

    // camera
    camera.x = player.x;
    camera.y = player.y;
    camera.zoom = 1.0;

    // --- 4) spawn small planets away from player
    smalls.length = 0;
    for (let i=0;i<CONFIG.smallPlanetCount;i++){
      smalls.push(spawnSmall(player.x, player.y, playerR()));
    }

    particles.length = 0;
    absorbedCount = 0;
    survivedSec = 0;
  }

  // ---------- Main loop
  let lastT = performance.now();

  function step(t) {
    const dt = Math.min(0.033, (t - lastT) / 1000);
    lastT = t;
    survivedSec += dt;


    // steering (hold+drag): smoothly rotate velocity direction toward the latest dragged target.
    {
      const now = performance.now();
      if (steer.lastUpdate > 0 && (now - steer.lastUpdate) <= STEER_ACTIVE_MS) {
        const sp = hypot(player.vx, player.vy);
        if (sp > 0.02) {
          const cx = player.vx / sp, cy = player.vy / sp;
          const tx = steer.dirX, ty = steer.dirY;
          const dot = clamp(cx*tx + cy*ty, -1, 1);
          const ang = Math.acos(dot);
          if (ang > 1e-4) {
            // Speed-dependent steering difficulty: above threshold, turning gets harder.
            let speedFactor = 1;
            if (sp > STEER_SPEED_THRESHOLD) {
              speedFactor = 1 / (1 + (sp - STEER_SPEED_THRESHOLD) / STEER_SPEED_SCALE);
              speedFactor = clamp(speedFactor, 0.15, 1);
            }
            const maxAng = STEER_RATE * dt * steer.strength * speedFactor;
            const stepAng = Math.min(ang, maxAng);
            const cross = cx*ty - cy*tx;
            const sgn = (cross >= 0) ? 1 : -1;
            const c = Math.cos(stepAng);
            const s = Math.sin(stepAng) * sgn;
            // rotate (cx,cy) by stepAng toward target sign
            const nx = cx*c - cy*s;
            const ny = cx*s + cy*c;
            player.vx = nx * sp;
            player.vy = ny * sp;
          }
        }
      }
    }

    // move player (constant inertia)
    player.x += player.vx * 60 * dt;
    player.y += player.vy * 60 * dt;
    wrapPos(player);

    // trail
    {
      const p = shiftIntoView(player.x, player.y);
      player.trail.push({x: p.x, y: p.y});
      if (player.trail.length > CONFIG.trailLength) player.trail.shift();
    }

    // move smalls
    for (const s of smalls) {
      s.x += s.vx * 60 * dt;
      s.y += s.vy * 60 * dt;
      wrapPos(s);
      s.vx += rand(-0.02, 0.02) * dt;
      s.vy += rand(-0.02, 0.02) * dt;
      s.vx *= 0.996; s.vy *= 0.996;

      const sp = shiftIntoView(s.x, s.y);
      s.trail.push({x: sp.x, y: sp.y});
      if (s.trail.length > CONFIG.trailLength) s.trail.shift();
    }

    // player gravity field affects smalls
    {
      const pr = playerR();
      const gRange = pr * CONFIG.playerGravityRangeMult;
      for (const s of smalls) {
        const {dx, dy} = torusDelta(s.x, s.y, player.x, player.y);
        const d = Math.max(0.001, hypot(dx, dy));
        if (d < gRange) {
          const nx = dx / d, ny = dy / d;
          const x = clamp(1 - (d / gRange), 0, 1);
          const fall = Math.pow(x, CONFIG.playerGravityFalloffPower);

          let accel = (CONFIG.playerGravityStrength * fall) * dt * 0.06;
          accel = Math.min(accel, CONFIG.playerGravityMaxAccel * dt);

          s.vx += nx * accel;
          s.vy += ny * accel;
        }
      }
    }

    // black holes: capture vs swing-by (keep speed)
    let bhProximity = 'none';

    for (const bh of blackholes) {
      const pullR = bh.r * CONFIG.bhPullRadiusMultiplier * CONFIG.bhRangeMultiplier; // ✅ 1.5배 적용
      const killR = bh.r * CONFIG.bhKillRadiusMultiplier;

      const {dx, dy} = torusDelta(player.x, player.y, bh.x, bh.y);
      const d = Math.max(0.001, hypot(dx, dy));
      if (d >= pullR) continue;

      const nx = dx / d, ny = dy / d;
      const x = clamp(1 - (d / pullR), 0, 1);
      const fall = Math.pow(x, CONFIG.bhFalloffPower);

      const v = hypot(player.vx, player.vy);
      const fast = v >= CONFIG.bhCaptureSpeed;

      // drain
      const near = clamp((pullR - d) / Math.max(1, pullR - killR), 0, 1);
      player.mass -= CONFIG.bhDrainPerSec * (1 + near * CONFIG.bhDrainNearMultiplier) * dt;

      if (d < killR * 2.2) bhProximity = 'danger';
      else if (bhProximity !== 'danger') bhProximity = 'warn';

      if (!fast && d < pullR * CONFIG.bhCaptureRadiusFactor) {
        // CAPTURE MODE: accelerate toward BH
        let accel = (bh.strength * fall) * dt * 0.00060 * CONFIG.bhCapturePull;
        accel = Math.min(accel, CONFIG.bhCaptureMaxAccel * dt);

        player.vx += nx * accel;
        player.vy += ny * accel;

        // slight swirl (spiral)
        const tx = -ny, ty = nx;
        const swirl = CONFIG.bhCaptureSwirl * fall * (bh.strength / (pullR*pullR + 1)) * 320 * dt;
        player.vx += tx * swirl;
        player.vy += ty * swirl;

      } else {
        // SWING-BY MODE: keep speed constant, only rotate direction
        const v0 = Math.max(0.001, v);
        const vx0 = player.vx / v0;
        const vy0 = player.vy / v0;

        let turn = CONFIG.bhSwingTurnRate * fall * dt;
        turn = Math.min(turn, CONFIG.bhSwingMaxTurnPerSec * dt);

        const cross = (vx0 * ny - vy0 * nx);
        const sign = (cross >= 0) ? 1 : -1;

        const c = Math.cos(turn);
        const s = Math.sin(turn) * sign;
        const rx = vx0 * c - vy0 * s;
        const ry = vx0 * s + vy0 * c;

        const bx = rx + nx * CONFIG.bhSwingPullAssist * fall;
        const by = ry + ny * CONFIG.bhSwingPullAssist * fall;
        const bn = Math.max(0.001, hypot(bx, by));

        player.vx = (bx / bn) * v0;
        player.vy = (by / bn) * v0;
      }

      if (d < killR + playerR()*0.25) {
        player.mass -= (CONFIG.bhDrainPerSec * 3.8) * dt;
      }

      // ✅ BH particles 10배+ (기존: 0.10*fall 확률로 1개)
      // 이제: fall 확률로 1개 + 가까울수록 추가 1개 더
      const chance = Math.min(1, CONFIG.bhParticleChanceBase * fall);
      if (Math.random() < chance) {
        const r = playerR();
        const ang = rand(0, Math.PI*2);
        const px = (player.x + Math.cos(ang) * r) % world.w;
        const py = (player.y + Math.sin(ang) * r) % world.h;
        spawnParticle(px, py, bh.x, bh.y, rand(2.2, 4.2), rand(0.35, 0.75), 32, 0.55);

        // extra close burst
        if (fall > 0.65 && Math.random() < Math.min(1, CONFIG.bhParticleExtraClose * fall)) {
          const ang2 = rand(0, Math.PI*2);
          const px2 = (player.x + Math.cos(ang2) * r) % world.w;
          const py2 = (player.y + Math.sin(ang2) * r) % world.h;
          spawnParticle(px2, py2, bh.x, bh.y, rand(2.2, 4.2), rand(0.35, 0.75), 32, 0.55);
        }
      }
    }

    // clamp speed for controllability
    {
      const cap = maxSpeedNow();
      const sp = hypot(player.vx, player.vy);
      if (sp > cap) {
        player.vx = (player.vx / sp) * cap;
        player.vy = (player.vy / sp) * cap;
      }
    }

    // absorb on contact
    {
      const pr = playerR();
      for (let i = smalls.length - 1; i >= 0; i--) {
        const s = smalls[i];
        const sr = radiusFromMass(s.mass);
        const d = torusDist(player.x, player.y, s.x, s.y);
        if (d <= pr + sr) {
          const gain = s.mass * CONFIG.absorbGainMultiplier;
          const oldMass = player.mass;
          player.mass += gain;

          player.vx = (player.vx * oldMass + s.vx * gain) / player.mass;
          player.vy = (player.vy * oldMass + s.vy * gain) / player.mass;

          const cap = maxSpeedNow();
          const sp = hypot(player.vx, player.vy);
          if (sp > cap) {
            player.vx = (player.vx / sp) * cap;
            player.vy = (player.vy / sp) * cap;
          }

          smalls.splice(i,1);
          absorbedCount++;
        }
      }
    }

    // particles update
    for (let i = particles.length - 1; i >= 0; i--) {
      const pt = particles[i];
      pt.life -= dt;
      if (pt.life <= 0) { particles.splice(i,1); continue; }
      pt.x += pt.vx * 60 * dt;
      pt.y += pt.vy * 60 * dt;
      wrapPos(pt);
      pt.vx *= Math.pow(0.995, 60*dt);
      pt.vy *= Math.pow(0.995, 60*dt);
    }

    if (player.mass <= CONFIG.playerMinMass) reset();

    // camera follow
    {
      const {dx, dy} = torusDelta(camera.x, camera.y, player.x, player.y);
      camera.x = ((camera.x + dx * CONFIG.camFollow) % world.w + world.w) % world.w;
      camera.y = ((camera.y + dy * CONFIG.camFollow) % world.h + world.h) % world.h;
    }

    // render
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,window.innerWidth, window.innerHeight);

    const cx = window.innerWidth * 0.5;
    const cy = window.innerHeight * 0.5;
    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-camera.x, -camera.y);

    drawStars();
    for (const s of smalls) drawSmall(s);
    for (const bh of blackholes) drawBlackHole(bh);
    drawParticles();
    drawPlayer();

    ctx.restore();

    // HUD
    const sp = hypot(player.vx, player.vy);
    const cls = (bhProximity === 'danger') ? 'danger' : (bhProximity === 'warn' ? 'warn' : '');
    if (statsEl) statsEl.innerHTML =
      `질량: <b class="${cls}">${player.mass.toFixed(1)}</b>` +
      ` | 반지름: ${playerR().toFixed(1)}` +
      ` | 중력권: ${(playerR()*CONFIG.playerGravityRangeMult).toFixed(0)}` +
      ` | 속도: ${sp.toFixed(2)}/${maxSpeedNow().toFixed(1)}` +
      ` | BH범위x: ${CONFIG.bhRangeMultiplier.toFixed(1)}` +
      ` | 흡수: ${absorbedCount}` +
      ` | 작은행성: ${smalls.length}` +
      ` | 블랙홀: ${blackholes.length}` +
      ` | 파티클: ${particles.length}` +
      ` | 생존: ${Math.floor(survivedSec)}s` +
      ` | 줌: ${camera.zoom.toFixed(2)}x`;

    updateMinimalUI();
    requestAnimationFrame(step);
  }

  // ---------- Start
  function init() {
    initWorldSizeOnce();
    makeStars();
    reset();
  }

  init();
  
  updateMinimalUI();
requestAnimationFrame(step);
})();
</script>
</body>
</html>